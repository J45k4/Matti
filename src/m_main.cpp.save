#include <stdio.h>
#include <sys/socket.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <cstdlib>
#include <cstring>
#include <unistd.h>
#include <vector>
#include <string>
#include <thread>
#include <list>
#include <pthread.h>
#include <time.h>
#include <stdlib.h>
#include <iostream>

using namespace std;

int keepalive_enabled = 1;
int keepalive_time = 50;
int keepalive_count = 3;
int keepalive_interval = 3;

class Matrix {
	int socketfd;
	string ip;
	string port;

	clock_t lastPacket;
	
public:
	Matrix(const char *ip, const char* port) {
		this->ip = ip;
		this->port = port;
	}
	
	~Matrix() {
		close(socketfd);
	}
	
	void setVideo(int con, int cpu) {
		char buffer[6] = {0x2, 71, 128 + con, 128 + cpu, 0x3};
		int len = strlen(buffer);
		ssize_t bytes_sent;
		bytes_sent = send(socketfd, buffer, len, 0);
		lastPacket = clock();		
	}
	
	void setKwm(int con, int cpu) {
		
	}
	
	void keepAlive() {
		
	}
	
	void setTimeout() {
		
	}
	
	int Connect() {
		cout << ip <<endl;
		cout << port <<endl;
		int status;
    	struct addrinfo host_info;
		struct addrinfo *host_info_list;
    	//int socketfd = -1;  
      
    	memset(&host_info, 0, sizeof host_info);
		host_info.ai_family = AF_UNSPEC;     // IP version not specified. Can be both.
  		host_info.ai_socktype = SOCK_STREAM;
      
		status = getaddrinfo(ip.c_str(), port.c_str(), &host_info, &host_info_list);
		if (status == 0) {
			cout << "Creating socketfd" <<endl;
			socketfd = socket(host_info_list->ai_family, host_info_list->ai_socktype, 
			setsockopt(socketfd, SOL_SOCKET, SO_KEEPALIVE, 1, 
			setsockopt(socketfd, IPPROTO_TCP, TCP_KEEPIDLE, keepalive_time, sizeof keepalive_time);
			setsockopt(socketfd, IPPROTO_TCP, TCP_KEEPCNT, keepalive_count, sizeof keepalive_count);
			setsockopt(socketfd, IPPROTO_TCP, TCP_KEEPINTVL, keepalive_interval, sizeof keepalive_interval);			
			host_info_list->ai_protocol);
			status = connect(socketfd, host_info_list->ai_addr, host_info_list->ai_addrlen);
		
		}
	
		return socketfd;		
	}
	
	int disconnect() {
		close(socketfd);
	}
	
	bool connected() {
		
	}
	
};


// ssize_t bytes_sent;

void timeoutService() {
	
}


int connectMatrix(const char* ip, const char* port) {

}


struct per_session_data {
    int fd;
};

static void INT_HANDLER(int signo) {
    //destroy_flag = 1;
}


int main() {
	
	// int status;
    // ssize_t bytes_sent;
    // struct addrinfo host_info;
	// struct addrinfo *host_info_list;
    // //int len = strlen(buffer);
	
	// //struct sockaddr_in serv_addr;
  	// //struct hostent *server;
    // int socketfd;  
      
    // memset(&host_info, 0, sizeof host_info);
	// host_info.ai_family = AF_UNSPEC;     // IP version not specified. Can be both.
  	// host_info.ai_socktype = SOCK_STREAM;
      
	// status = getaddrinfo("192.168.180.98", "5555", &host_info, &host_info_list);
	// if (status == 0) {
	// 	socketfd = socket(host_info_list->ai_family, host_info_list->ai_socktype, 
	// 	host_info_list->ai_protocol);
	// 	if (socketfd != -1) {
	// 		status = connect(socketfd, host_info_list->ai_addr, host_info_list->ai_addrlen);
	// 		if (status != -1) {
	// 			//connected = true;
    //             printf("Socket made succefully!! socketfd=%d\n", socketfd);
	// 		} else cout << "Failed when connecting socket" <<endl;
	// 	} else cout << "Failed when creating socket" <<endl;
	// } else {
	// 	cout << "Failed to get address" <<endl;
	// }
	
	
	// const char *interface = NULL;
    // struct lws_context_creation_info info;
    // struct lws_protocols protocol;
    // struct lws_context *context;
    // // Not using ssl
    // const char *cert_path = NULL;
    // const char *key_path = NULL;
    // // no special options
    // int opts = 0;
  	// //* register the signal SIGINT handler */
    // struct sigaction act;
    // act.sa_handler = INT_HANDLER;
    // act.sa_flags = 0;
    // sigemptyset(&act.sa_mask);
    // sigaction( SIGINT, &act, 0);
	
	Matrix matrix("192.168.180.98", "5555");
	matrix.Connect();
	
	
	
	// while(1) {
		
	// }
	
	
// clock_t start, end;
// double cpu_time_used;

// start = clock();

// end = clock();
// cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
	
	int con, cpu;
	while(1) {
		cin >> con;
		cin >> cpu;
		cout << "socket fd " << socketfd << endl;
		matrix.setVideo(con, cpu);
		//char buffer[6] = {0x2, 71, 128 + con, 128 + cpu, 0x3};
		//int len = strlen(buffer);
		//bytes_sent = send(socketfd, buffer, len, 0);
	}
		
	return 0;
}
